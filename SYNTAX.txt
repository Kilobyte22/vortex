(* Buttscript 0.1 syntax in extended BNF *)

(* alphabetic characters *)
alpha = 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K'
      | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V'
      | 'W' | 'X' | 'Y' | 'Z' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g'
      | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r'
      | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z';

(* digits *)
digit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9';

(* chunks of buttscript code *)
chunk = { statement }, [ ret_statement ];

(* blocks are expressions. *)
block = '{', chunk, '}';

(* block shorthand so it's possible to omit -> in certain places *)
block_short = '->', expr | block;

(* string literal *)
string_literal = (''' | '"'), ? any valid Lua string constant ?, (''' | '"');

(* number literal *)
number_literal = ? any valid Lua numerical constant ?;

(* a table literal *)
table_literal = '[', [ fields ], ']';

(* a function literal *)
function_literal = 'fn', function_args, block_short;

(* a single function arg *)
function_arg = ident, [ '=', expr ] | '...';

(* function arguments *)
function_args = functon_arg, { ',', function_arg };

(* any literal *)
literal = string_literal | number_literal | table_literal | function_literal;

(* fields *)
fields = field { field_delim, field } [ field_delim ];

(* field delimiter *)
field_delim = ',' | ';';

(* identifiers consist of underscores, alphabetic characters
 * and digits (identifiers cannot start with digits though)
 *)
ident = ('_' | alpha), { '_' | alpha | digit };

(* a list of identifiers, comma separated *)
idents = ident, { ',', ident };

(* a return statement *)
ret_statement = 'ret', exprs, [ ';' ];

(* a label used with goto statement *)
label = '::', ident, '::';

(* an expression *)
expr = literal
     | prefix_expr
     | control_expr
     | block
     | '...'
     | expr, binary_op, expr
     | unary_op, expr;

(* a list of expressions, comma separated *)
exprs = expr, { ',', expr };

(* a prefix expression *)
prefix_expr = '(', expr, ')' | function_call | variable;

(* a control expression *)
control_expr = 'if', expr, block_short, [ 'else', block_short ]
             | 'while', expr, block_short
             | 'do', block_short, 'while', expr
             | 'for', idents, 'in', exprs, block_short;

(* a variable *)
variable = ident | prefix_expr, '[', expr, ']' | prefix_expr, '.', ident;

(* a list of variables, comma separated *)
variables = variable, { ',', variable };

(* a function call *)
function_call = prefix_expr, '(', idents, ')'
              | prefix_expr, ':', ident, '(', idents, ')'
              | prefix_expr, string_literal;

(* function call arguments *)
call_args = '(', [ exprs ], ')' | string_literal;

(* a binary operator *)
binary_op = '+' |  '-' | '*' | '/' | '+=' | '-=' | '*=' | '/=' | '<-'  | '^'
          | '%' | '..' | '<' | '<=' | '>' | '>=' | '==' | '!=' | 'and' | 'or';

(* a unary operator *)
unary_op = '#' | '-' | 'not';

(* a statement - return statement handled separately *)
statement = ';'
          | variables, '=', exprs
          | function_call
          | control_expr
          | 'let', idents, [ '=', exprs ]
          | label
          | 'goto', ident
          | 'break'
          | 'continue';
