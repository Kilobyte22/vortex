% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

\documentclass{article}
\usepackage[utf8]{inputenc}

\usepackage{geometry}
\geometry{a4paper}
% \geometry{margin=2in} % for example, change the margins to 2 inches all round

\usepackage{graphicx} % support the \includegraphics command and options
\usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent

\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
% These packages are all incorporated in the memoir class to one degree or another...
\usepackage{textcomp}

%%% HEADERS & FOOTERS
\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}

%%% SECTION TITLE APPEARANCE
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape} % (See the fntguide.pdf for font help)
% (This matches ConTeXt defaults)

%%% ToC (table of contents) APPEARANCE
\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC
\usepackage[titles,subfigure]{tocloft} % Alter the style of the Table of Contents
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % No bold!

\usepackage{csquotes}
\usepackage{listings}
\usepackage{color}

\definecolor{keyword1}{RGB}{0,102,153}
\definecolor{keyword2}{RGB}{0,153,102}
\definecolor{keyword3}{RGB}{0,153,255}
\definecolor{comment}{RGB}{204,0,0}
\definecolor{function}{RGB}{153,102,255}
\definecolor{digit}{RGB}{255,0,0}
\definecolor{string}{RGB}{255,0,204}
\definecolor{rule}{RGB}{192,192,192}
\definecolor{back}{RGB}{250,250,250}

\lstdefinelanguage{vortex}{
  keywordstyle={\color{keyword2}\bfseries},
  keywordstyle=[2]{\color{keyword1}\bfseries},
  keywordstyle=[3]{\color{keyword2}\bfseries},
  keywordstyle=[4]{\color{keyword3}\bfseries},
  keywords={},
  morekeywords=[2]{and,as,asr,band,bnot,bor,break,bsl,bsr,bxor,case,cfn,clone,coro,cycle,do,
    else,end,enum,fn,for,goto,if,in,let,loop,macro,match,module,new,not,or,quote,redo,result,
    return,seq,set,unquote,when,while,with,yield},
  morekeywords=[3]{glob,rec,assert,self,super},
  morekeywords=[4]{__FILE__,__LINE__,false,nil,true},
  otherkeywords={->},
  morecomment=[l][\color{comment}]{//},
  morecomment=[s][\color{comment}]{/*}{*/},
  stringstyle=\color{string},
  morestring=[b]",
  morestring=[b]',
  morestring=[b]""",
  morestring=[b]''',
  showstringspaces=false,
  frame=single,
  rulecolor=\color{rule},
  backgroundcolor=\color{back},
  numbers=left
}

\lstdefinelanguage{bnf}{
  keywordstyle={\color{keyword2}\bfseries},
  keywords={},
  otherkeywords={::=,|},
  morecomment=[s][\color{comment}]{(*}{*)},
  stringstyle=\color{string},
  morestring=[b]",
  morestring=[b]',
  morestring=[b]/,
  showstringspaces=false,
  frame=single,
  rulecolor=\color{rule},
  backgroundcolor=\color{back}
}

\lstdefinelanguage{text}{
  frame=single,
  rulecolor=\color{rule},
  backgroundcolor=\color{back}
}

%%% END Article customizations

%%% The "real" document content comes below...

\title{The Vortex programming language}
\author{Daniel "q66" Kolesa}
%\date{} % Activate to display a given date or no date (if empty),
         % otherwise the current date is printed 

\begin{document}
\maketitle
\thispagestyle{empty}

\abstract
Vortex is a scripting language created to explore the possibilities of using
Lua as an intermediate language. While compiling to performant Lua (comparable
to handwritten code), Vortex tries to simplify programming by introducing new
features (such as lambda expressions, macros, lists and objects) that Lua
lacked before (while not introducing anything that is not present in regular
Lua). Vortex gains inspiration from well known programming languages mainly
in the functional paradigm, such as OCaml, F\#, Scheme and Rust besides Lua
itself. The language itself tries to offer the programmer multiple paradigms
-- functional, procedural, object oriented (prototype based -- delegative with
    multiple inheritance) and metaprogramming. Vortex does not try to create a
\enquote{preprocessor} for Lua (akin to attempts like CoffeeScript/MoonScript).

\newpage
\thispagestyle{empty}
\tableofcontents
\pagebreak
%\setcounter{page}{1}

\section{Introduction}
This document attempts to create a reference manual for the Vortex programming
language. It tries to cover:
\begin{itemize}
  \item Various aspects of the language, including lexical analysis and all of
      the language's structures. The standard library is not covered (and at
      the point of writing, not yet designed).
  \item Rationale for many of the language features.
  \item Examples of usage.
\end{itemize}
It tries to be just documentation, not a tutorial. For a tutorial, check out
other sources (such as the Vortex wiki).
\subsection{Disclaimer}
Vortex is still in heavy development. This document will change as the language
changes -- do not use it in production. While the basic idea and style is
given, language features may appear, change and vanish. The implementation
may not reflect the actual state of the language. Some features described here
are not yet implemented at the time of writing. Unimplemented features will be
clearly marked as such in their section headers.
\subsection{Conventions}
The formal grammar of Vortex specified here is written using an extended
dialect of BNF. The BNF strings may contain \verb|/regexes/|. Example code is
written using \verb|monospace| blocks. Character ranges may be used for obvious
things, such as \verb|a-Z| or \verb|0-9|.

\section{Concepts}
Vortex shares most of the basic concepts with Lua.
\subsection{Variables and values}
Vortex is an untyped language, or unityped to be precise -- there is a single
data type in the language, a value, similar to Lua, Python, JavaScript and
so on. The values are tagged. The variable holds the data type and its value
holds the tag.\\
Vortex type tags are shared with Lua, being represented by \verb|nil|,
\verb|boolean|, \verb|number|, \verb|string|, \verb|function|,
\verb|userdata|, \verb|thread| and \verb|table|. The \verb|nil| tag can have
a single value, \verb|nil|. The \verb|boolean| tag can have the \verb|true|
and \verb|false| values. The only two values that evaluate as false in
conditions are \verb|false| and \verb|nil|. The tag \verb|number| represents
a floating point number (by default double precision), depending on the
underlying C. The tag \verb|string| is an immutable sequence of bytes.
Vortex is like Lua 8-bit clean. Strings can contain any byte, including
embedded zeros.\\
The tag \verb|userdata| has the same meaning as in Lua. The managed kind
represents a managed (garbage collected) block of memory that can have
a metatable. The light kind represents a raw pointer. The tag \verb|thread|
is represented by coroutines which are identical with Lua's. Functions are
represented using the tag \verb|function|. They're transparent closures.\\
And finally \verb|table| is the ultimate do-it-all data structure of Vortex.
It represents an associative array (unordered hash map). It's heterogenous,
being able to hold any arbitrary value except nil in both key and value
positions.\\
Vortex also has lists. These are similar to lists in Lisp or other functional
languages. They don't hold their own tag -- they're tables with specific
behavior.\\
Functions, threads, full userdata and tables are always accessed by reference,
everything else by value (copied). All values are first class values. You can
store them, pass them around and return from functions.\\
There are two types of variables in Vortex, locals and table fields. Global
variables are merely fields of the global table called \verb|_G|. Local and
global variables have to be declared before they can be assigned or used,
which is different from Lua, where assignment to undeclared variable creates
a global and reading an undeclared variable results in the \verb|nil| value.
You declare and define variables using the \verb|let| expression.

\section{Lexical}
Vortex utilizes a fully free form syntax. Whitespace of any form is ignored,
used only to delimit tokens where it would otherwise be ambiguous.
\subsection{Encoding}
\begin{lstlisting}[language=bnf]
alpha    ::= 'a-zA-Z'
digit    ::= '0-9'
hexdigit ::= '0-9a-fA-F'
\end{lstlisting}
The input is a sequence of bytes. Vortex does not handle Unicode in any way,
but it's UTF-8 clean. All of the grammar is confined to the ASCII. Because
it's UTF-8 clean, Unicode strings and such are allowed and passed to the
output without any processing. If an UTF-8 BOM is found, it's skipped
automatically. If a shebang line is found in the beginning, it's skipped
as well.
\subsection{Whitespace}
\begin{lstlisting}[language=bnf]
whitespace ::= ' ' | '\n' | '\r' | '\t' | '\f' | '\v'
\end{lstlisting}
The Vortex lexer does not care about whitespace for anything else than token
separation. Whitespace is not needed to separate tokens; the source is simply
read character by character and when a token ending is found, it just goes on
to the next one. The BNF above shows all possible forms of whitespace in
Vortex. As you can see, newlines are treated as regular whitespace as well
(with the exception of incrementing the line number). Newline and carriage
return can be used in pairs no matter what order (handles the common cases
'\textbackslash n' and '\textbackslash r\textbackslash n' plus
'\textbackslash n\textbackslash r' for rare platforms).
\subsection{Comments}
% ugly textcolor hack to make some editors happy with escaped $
\begin{lstlisting}[language=bnf,mathescape]
comment ::= '//' /.*$\textcolor{string}{\$}$/ | '/*' { /./ | comment } '*/'
\end{lstlisting}
Vortex uses C(++) style comments. Short comments comment out everything until
the end of the line. Long comment can span multiple lines and are enclosed
between delimiters. Unlike C(++), Vortex allows for nesting of comments
(thus it requires you to keep them balanced). Comments do not get past
lexical analysis.
\subsection{Identifiers}
\begin{lstlisting}[language=bnf]
ident ::= ('_' | alpha) { '_' | alpha | digit }
identlist ::= [ ident { ',' ident } ]
\end{lstlisting}
Vortex identifiers (names) can consist of alphanumeric characters (ASCII only)
and underscores. They can't start with a digit, but a digit can be present
anywhere else in the identifier. Identifiers starting with an underscore
followed by an uppercase character are reserved. This is by convention and
not enforced by the compiler.
\subsection{Keywords}
\begin{lstlisting}[language=bnf]
opkeyword ::= 'band' | 'bor' | 'bxor' | 'asr' | 'bsr' | 'bsl'
            | 'and' | 'or'
opkeywordass ::= 'band=' | 'bor=' | 'bxor=' | 'asr=' | 'bsr='
               | 'bsl='
keyword ::= 'as' | 'break' | 'case' | 'cfn' | 'clone' | 'coro'
          | 'cycle' | 'do' | 'else' | 'end' | 'enum' | 'false'
          | 'fn' | 'for' | 'glob' | 'goto' | 'if' | 'in' | 'let'
          | 'loop' | 'macro' | 'match' | 'module' | 'new' | 'nil'
          | 'quote' | 'rec' | 'redo' | 'result' | 'return' | 'seq'
          | 'set' | 'true' | 'unquote' | 'when' | 'while' | 'with'
          | 'yield' | '__FILE__' | '__LINE__' | opkeyword
          | opkeywordass | unopkeyword
unopkeyword ::= 'not' | 'bnot'
\end{lstlisting}
These are \enquote{reserved words} in Vortex. They cannot be used as
identifiers. Some of these specified in \verb|opkeyword| have an assignment
form. Vortex is case sensitive, the keywords only are keywords in lowercase.
For example, \verb|match| is a keyword but \verb|MATCH| or \verb|Match| can
be used as valid identifiers.
\subsection{Other tokens}
\begin{lstlisting}[language=bnf]
binop ::= '=' | '==' | '>' | '>=' | '<' | '<=' | '!=' | '%' | '~'
        | '+' | '++' | '*' | '**' | '-' | '/' | '::'
        | opkeyword
assop ::= '~=' | '+=' | '++=' | '*=' | '**=' | '-=' | '/=' | '::='
        | '%=' | opkeywordass
unop ::= '-' | 'not' | '#' | unopkeyword
valuetok ::= <string> | <number> | <ident>
othertok ::= '(' | ')' | '->' | '.' | '..' | '...' | ';' | ';;'
           | '$' | '$(' | <eos>
\end{lstlisting}
Here you can see all the other tokens used by Vortex with separate categories
for binary, unary and assignment operators and tokens holding a value.
\subsection{Number literals}
\begin{lstlisting}[language=bnf]
hexnum ::= ('0x' | '0X') { hexdigit } [ '.' ] { hexdigit }
    [ ('p' |'P') [ '+' |'-' ] digit ]
decnum ::= { digit } [ '.' ] { digit } [ ('e' | 'E')
    [ '+' | '-' ] digit ]
numliteral ::= hexnum | decnum
\end{lstlisting}
Vortex does not make a difference between integers and floats. Numbers follow
the Lua format. Hexadecimal numbers start with \verb|0x| or \verb|0X| (the
former is better). In numbers like \verb|0.6| you can omit the zero and write
just \verb|.6|. Hexadecimal constants behave similarly. Optional decimal
exponent is marked with \verb|e| or \verb|E| (binary exponent in hex constants
is \verb|p| or \verb|P|).
\subsection{String literals}
\begin{lstlisting}[language=bnf]
strliteral   ::= strprefix (strlong | strshort)
strprefix    ::= /[eErR]*/
strshort     ::= '"' strshortelem '"' | "'" strshortelem "'"
strlong      ::= '"""' strlongelem '"""' | "'''" strlongelem "'''"
strshortelem ::= ? short string contents ? | stresc
strlongelem  ::= ? long string contents ? | stresc
stresc       ::= '\\a' | '\\b' | '\\f' | '\\n' | '\\r' | '\\t'
               | '\\v' | '\\z' | '\\"' | "\\'" | '\\'
\end{lstlisting}
String literals in Vortex are similar to Python's. They are represented by the
\verb|<string>| token in the final stream. There are two types of string
literals, short and long literals.\\
Short literals are delimited with either single or double quotes and
typically hold a single line. They interpret escape sequences. A backslash at
the end of the line can be used to make them span multiple lines. You need to
escape nested single or double quotes depending on the used delimiter (e.g.
single quote delimited strings need to escape nested single quotes but
not double quotes).\\
Long literals behave similarly. They're delimited by three repeated either
single or double quotes. Escape sequences work the same, and long literals can
span multiple lines without backslashes. You don't need to escape quotes except
when three subsequent quotes are used (because otherwise they'd terminate the
string).\\
You can prefix both types of literals with either \verb|e| or \verb|r| (and
uppercase versions -- no difference there). The former enables interpolation
on that string -- it will interpret \verb|$var| and \verb|$(expr)| in the
string, where \verb|var| is any Vortex variable you can access at that point
and \verb|expr| is any Vortex expression. For example
\begin{lstlisting}[language=vortex]
for k, v in pairs([ 5, 10, 15 ]) -> print(e"$k -> $(v + 2)")
\end{lstlisting}
will print
\begin{lstlisting}[language=text]
1 -> 7
2 -> 12
3 -> 17
\end{lstlisting}
Interpolated strings allow you to escape the dollar sign to prevent
interpolation.
\\
The latter prefix turns the strings into raw strings. That means no escape
sequences are interpreted and instead they apparear in the result verbatim.
If you escape quotes, the backslashes will be visible in the string. The same
applies about backslashes used to escape newlines in short literals.\\
There is one non-standard escape sequence, \verb|\z|. It skips the following
span of whitespace characters (including newlines) in both short and long
literals. That is useful to break a short string literal into multiple lines
and indent the lines without actually including the newlines and indentation
in the string.\\
You can also insert an arbitrary byte in the string. That can be done either
with an escape sequence \verb|\xXX|, where \verb|XX| is a sequence of two
hexadecimal digits (e.g. \verb|\x4F| for uppercase O) or with an escape
sequence \verb|\ddd| where \verb|ddd| is a sequence of up to three decimal
digits (\verb|\79| would be the uppercase O).

\section{Expressions}
\begin{lstlisting}[language=bnf]
exp ::= statexp
explist ::= [ exp { ',' exp } ]
\end{lstlisting}
Vortex is a language that consists purely of expressions. No statements are
present in the language in that sense an expression of any type can appear
in any context. One exception is block scopes. Only expressions that can
cause some sort of side effect can appear there (e.g. variable assignment,
function call and so on, in the BNF they're called \verb|statexp|).
The rationale for this is that doing it otherwise doesn't really make sense
-- allowing inclusion of arbitrary expressions in blocks would result in code
doing nothing, and that's better filtered out at compile time.
\subsection{Main scope}
\begin{lstlisting}[language=bnf]
chunk ::= { statexp [ ';' ] } [ (retexp | resexp) [ ';' ] ]
\end{lstlisting}
The parsing of Vortex begins in the main scope. The main scope is a chunk.
A chunk is a sequence of side effect based expressions optionally separated
with semicolons. It may be ended with either a \verb|return| or a \verb|result|
expression. Having another expression after one of these results in syntax
error.
\subsection{Blocks}
\begin{lstlisting}[language=bnf]
blockend ::= 'end' | ';;'
block    ::= 'do' chunk blockend
statexp  ::= block
\end{lstlisting}
Blocks represent chains of expressions. A block consists of a \verb|do|
keyword, a chunk (see above) and either an \verb|end| keyword or two
semicolons. The semicolon ending is useful in inline blocks or in
Lisp style formatted code. Blocks themselves are expressions. The \verb|result|
expression can be used to specify their value.
\subsection{Binary and unary expressions}
\begin{lstlisting}[language=bnf]
assexp  ::= (ident | indexp) assop exp
binexp  ::= exp binop exp
unexp   ::= unop exp
exp     ::= binexp | unexp
statexp ::= assexp
\end{lstlisting}
Binary expressions are expressions that consist of two operands and an
operator. The operator is in infix form. The BNF here does not describe
operator precedences. Assignment operators are treated differently as
it's required to ensure that the left operand is an lvalue (you can't
assign an arbitrary expression). Assignment expressions can also be used in
statement form, unlike any other binary expression.\\
Unary expressions are expressions that consist of an operand and an operator
in prefix form.
Here you can see operator precedences for binary and unary operators in Vortex.
\begin{center}
\begin{tabular}{| l | l | l |}
\hline
\textbf{Operator} & \textbf{Precedence} & \textbf{Associativity} \\ \hline
=, +=, -=, *=, /=, \%=, \~{}=, ++=, ::=, **=, & 1 & right \\
band=, bor=, bxor=, asr=, bsr=, bsl= & & \\ \hline
or & 2 & left \\ \hline
and & 3 & left \\ \hline
==, != & 4 & left \\ \hline
\textless, \textless=, \textgreater, \textgreater= & 5 & left \\ \hline
\~{} & 6 & right \\ \hline
bor & 7 & left \\ \hline
bxor & 8 & left \\ \hline
band & 9 & left \\ \hline
asr, bsr, bsl & 10 & left \\ \hline
+, - & 11 & left \\ \hline
*, /, \% & 12 & left \\ \hline
++ & 13 & left \\ \hline
:: & 14 & right \\ \hline
-, not, \#, bnot & 15 & unary \\ \hline
** & 16 & right \\ \hline
\end{tabular}
\end{center}
Most of the operators should be clear when it comes to meaning. Assignment
operators in form \verb|lhs op= rhs| are equivalent to \verb|lhs = lhs op rhs|.
\verb|~| means concatenation, \verb|++| is a join operator (for tables),
\verb|::| is a cons operator (as in Lisp), \verb|#| retrieves the length
of the given expression, \verb|**| raises lhs to a power of rhs. \verb|band|,
\verb|bor|, \verb|bxor|, \verb|asr|, \verb|bsr|, \verb|bsl| mean bitwise AND,
bitwise OR, bitwise XOR, arithmetic right shift, bitwise right shift and
bitwise left shift respectively. The rest of the operators is functionally
equivalent to those in C.
\subsection{Primary expressions}
\begin{lstlisting}[language=bnf]
primaryexp ::= '(' exp ')' | tableexp | listexp | '$(' exp ')'
             | '$' ident | ident [ '!' '(' explist ')' ]
             | numliteral | strliteral | 'nil' | 'true'
             | 'false'
exp ::= primaryexp
\end{lstlisting}
Primary expressions are simple expressions that can have a suffix. A suffix
is for example a parameter list (a call), brackets with an expression
(indexing) or a dot (simple indexing). Primary expressions typically don't
have a side effect, thus they can't be used in statement form unless postfixed
as a call. You can wrap any arbitrary expression in parens to get a primary
expression. All types of simple literals as well as table and list literals
and macro expansions are primary expressions.
\subsection{Suffixed expressions}
\begin{lstlisting}[language=bnf]
fcallsuffix ::= '(' explist ')' | tableexp | strliteral
mcallsuffix ::= ':' ident fcallsuffix
tcallsuffix ::= fcallsuffix | mcallsuffix
indexsuffix ::= '.' ident | '[' exp ']'
expsuffix   ::= [ expsuffix ] (indexsuffix | tcallsuffix)
suffixedexp ::= primaryexp expsuffix
exp         ::= suffixedexp
statexp     ::= suffixedexp tcallsuffix
\end{lstlisting}
Suffixed expressions are primary expressions with a suffix. A suffix
represents either a call or indexing. Suffixes can be chained. In statement
form, only calls are allowed (not indexing alone). Indexing can be represented
in two forms. The simpler form consists of an expression, a dot and a name.
The name must be a valid indentifier. The more comprehensive form consists
of an expression and an index enclosed in brackets (the index can be an
arbitrary expression). Writing \verb|foo.bar| is equivalent to
\verb|foo["bar"]| assuming \verb|"bar"| contains no non-identifier
characters.\\
Calls can be either method calls \verb|obj:mname(args)| or regular
calls \verb|funcname(args)|. The former is just syntactic sugar for
\verb|obj.mname(obj, args)|. If the sole argument is a table or string literal,
you can omit the parens. That means writing \verb|funcname "foo"| and
\verb|funcname { 5, 10, 15 }| is equivalent to \verb|funcname("foo")| and
\verb|funcname({ 5, 10, 15 })| respectively.
\subsection{Let expression}
\begin{lstlisting}[language=bnf]
lettype ::= 'rec' | 'glob'
letexp  ::= 'let' [ lettype ] (pattern | '(' patternlist ')')
    '=' (suffixedexp | '(' explist ')')
\end{lstlisting}
The \verb|let| expression provides means to declare and define variables.
It consists of the keyword, a pattern or a pattern list enclosed in parens,
an assignment operator and either a suffixed expression or an expression
list enclosed in parens.\\
You can also optionally provide modifier after the keyword. The modifier
can currently be either \verb|rec| or \verb|glob|. The former is best used
with functions -- it makes it possible for a variable to access itself and
that way you can define recursive functions. Normally functions can't access
themselves. The latter is used to define a global variable -- by default,
all Vortex variables are local.\\
You can't normally declare a variable without definition. However, you can
assign nil to it, which is the same in meaning.\\
For patterns, look up the section about pattern matching. Note that only
patterns that never fail to match can be used with \verb|let|. For convenience,
the table pattern always matches in let but doesn't have to in regular
pattern matching (that is because in let you sometimes want to extract
just a few elements of an array, but in pattern matching you want it
precise).\\
An example of let expression:
\begin{lstlisting}[language=vortex]
let x = 5; // local variable x
let glob y = 10; // global variable y
fn foo() -> [ 5, 10, 15 ]
let [ a, b ] = foo() // a is 5, b is 10 - pattern usage
fn rec bar() -> bar() // recursive
\end{lstlisting}
\subsection{Functions}
\begin{lstlisting}[language=bnf]
defarglist ::= [ ident '=' exp { ',' ident '=' exp } ]
arglist    ::= identlist defarglist [ [ ident ] '...' ]
fnliteral  ::= 'fn' (arglist | '(' arglist ')') ('->' exp | block)
fndef      ::= 'fn' ([ lettype ] ident | ident [ '.' ident ])
    '(' arglist ')' ('->' exp | block)
statexp    ::= fndef
exp        ::= fnliteral
\end{lstlisting}
Vortex features first class functions. That means a function can be treated
as a first class citizen -- you can pass it as an argument or return it from
another function. Like in Lua, functions are passed by reference -- you never
access the function value directly, you only access its reference.\\
You can create a function two ways. The first way is an anonymous function.
Because anonymous functions don't have names, you need to assign it to a
variable. It looks like this:
\begin{lstlisting}[language=vortex]
let add = fn a, b -> a + b
print(add(5, 10))
\end{lstlisting}
You can optionally put parens around the argument list. The second way is
a named function. Given the previous example, you can rewrite your function
as:
\begin{lstlisting}[language=vortex]
fn add(a, b) -> a + b
\end{lstlisting}
Named functions can be defined as table members. For example:
\begin{lstlisting}[language=vortex]
let tbl = {}
fn tbl.foo() -> "hello world"
\end{lstlisting}
They can also have modifiers, the same ones as the \verb|let| expression
(unless defined as table members -- then it doesn't make sense). Named
function definitions follow the same rules as the \verb|let| expression.
By default, named functions are local.
\begin{lstlisting}[language=vortex]
let foo = fn -> foo() // won't work - non-recursive
let rec bar = fn -> bar() // works - bar previously declared
fn foo() -> foo() // won't work
fn rec bar() -> bar() // works
\end{lstlisting}
Named functions can be used as statements. Anonymous functions can't.\\
Now, if you look at the examples, you can see they're pretty much lambda
expressions. They take inputs and they return the value specified after
the arrow. You can combine that with blocks. Both \verb|return| and
\verb|result| can be used to specify the function return value. The
former simply jumps out of the function and makes it return the value,
the latter specifies the value of the block which the function then
returns. The result is pretty much the same.
\begin{lstlisting}[language=vortex]
fn foo() -> do
    ...
end
\end{lstlisting}
The arrow feels kinda superfluous. Vortex allows you to omit it:
\begin{lstlisting}[language=vortex]
fn foo() do
    ...
end
\end{lstlisting}
Function arguments in Vortex can have default values. After you specify
the first default value, every argument after that one must specify a default
value. Example:
\begin{lstlisting}[language=vortex]
// you can reference the previous arguments too
fn foo(a, b = 5, c = b + 2, d = c + 3) do
    ...
end
\end{lstlisting}
You can end the argument list with an ellipsis argument. That means the
function will be variadic and you can access the remaining arguments
passed to the function again using an ellipsis. Example:
\begin{lstlisting}[language=vortex]
fn printf(fmt, ...) do
    print(fmt:format(...))
end
\end{lstlisting}
You can name the vararg tuple and pass it around as a table like this:
\begin{lstlisting}[language=vortex]
fn foo(a, b...) do
    print(a, b[1], b[2])
end
\end{lstlisting}
That is functionally equivalent to:
\begin{lstlisting}[language=vortex]
fn foo(a, ...) do
    let b = { ... }
    print(a, b[1], b[2])
end
\end{lstlisting}

\section{The REPL}
Vortex provides an interactive command line and a standalone script runner
combined into a single script. By default it launches an interactive session.
There you can input statements.\\
Local variables are preserved.
\begin{lstlisting}[language=vortex,numbers=none]
> let x = { 5, 10, { 15, 20 } }
> =x // proper output
{ 5, 10, { 15, 20 } }
\end{lstlisting}
The Vortex REPL in the default implementation is itself written in Vortex.
It requires a Lua module called \verb|vxutil|. This module is shipped with
Vortex and is written in C -- you need to compile it and then put into a
Lua C module search path (for example the current directory). The C module
provides support for signals, \verb|isatty| and the readline library. All
functions have their fallbacks. For example, if you want readline support in
the REPL (so that you can move in the history and seek in the current input),
you need to compile the C module with \verb|VX_READLINE| defined. For proper
function of \verb|isatty| you need to compile the module with either
\verb|VX_POSIX| or \verb|VX_WIN| defined depending on your platform. If you
don't define either of these, a fallback will always return true, which
means autodetection whether to launch an interactive session won't work
(when \verb|isatty| returns false, it means something is piped into the
standard input, and the REPL tries to execute that).
\begin{lstlisting}[language=text]
usage: vortex [options] [script [args]]
-e str  run the string 'str'
-i      enter interactive mode after the options are handled
-l lib  require library 'lib'
-v      show version information
--      stop handling options
-       stop handling options and run stdin
\end{lstlisting}
Here you can see the REPL options you can pass to it. As mentioned above,
you can use the REPL with pipes. For example
\begin{lstlisting}[language=text]
echo 'print("hello world")'|<replcommand>
\end{lstlisting}
should work.\\
If your interactive line starts with \verb|=| followed by an expression,
the REPL prints its value. You can see an example in the very beginning
of this section. Tables get special treatment -- they're serialized before
printing. That should allow you to see the values clearly.

\section{Appendix: Influences}
Vortex is a language with many influences. It follows the same principles as
Lua, on which is built. Thus, you can find many similarities in Lua's and
Vortex's syntax and semantics as well as the core set of features. Vortex and
Lua are both built around tables, the ultimate do-it-all data structure.
The reliance on higher order and first class functions is also taken very
seriously in both languages.\\
The second largest influence for Vortex is OCaml. Vortex takes many primarily
syntactic features from OCaml, including the pattern matching syntax. Vortex
is however, unlike OCaml, an untyped language. The features are thus adjusted
accordingly for Vortex.\\
OCaml's relative, F\#, is also influental for Vortex. The basic idea of
sequences in place of list comprehensions is taken from F\#, but unlike
F\# sequences are not values in Vortex, instead they're simply tuples
of values that can't be treated in a first class manner.\\
The prototype based multiple inheritance object system of Vortex is inspired
by Io. Compared to Io, the constructors work differently and Vortex's object
system allows you to pretty much closely imitate classes (those are handled
a bit differently in Io).\\
Scheme inspired Vortex in how simple a language can be while remaining very
powerful. Along with Elixir, Scheme provided a basis for Vortex AST macros.\\
Elixir and Ruby influenced Vortex's syntax. The Rust language provided an
example how terse a syntax can be and several of Vortex's keywords are or
were taken from Rust. The \verb|cycle| keyword is taken from Fortran.
String literal syntax is taken from Python.\\
Other languages that influenced Vortex to some degree are ALGOL, C, CLU,
Haskell and Self.

\end{document}
